Note 1:
Operating system:

1.Software layer between user applications and hardware: 
	i. Turns ugly hardware into beautiful abstractions
	ii. Serves as a resources manager
		i. allows proper use of resources
	iii. Serves as a control program(protection)
		i. controls execution of user programs to prevent errors and improper use of the computer

2.OS does and includes:
synchronization scheduling memory mgmt file system networking machine-dependent-code

Storage Hiararchy
1. Processor registers, main memory and auxiliarry memory form a rudimentary memory hierarchy
2. the hierarchy can be classifies according to memory speed, cost, and volatility
3. caches can be installed to hide performances differences when there is a large access-time gap between 
two levels

Storage structure
1. DRAM(Main memory) stores programs and data during program execution
	i. It can not store these permanently because it is too small and it is a volatile storage device
	ii. Forms a large array of bytes of memory, each with its own address
		a. it is by-te addressable

Caching

1. Definition: When the processor accesses info at some level of storage hierarchy, that info maybe copied to a cache
memory closer to the processor, on a temporary basis
	i. A cache is smaller and costlier

2. Because caches have limited size, cache management is an important design problem
	i. coherency

Concurrency
1. Every modern computer is a multiprocessor
	i. CPU and device controllers can execute concurrently, competing for memory cycle
	ii. A memory controller synchronizes access to shared memory
	iii. interrupts allow device controllers to signal the CPU that some event has occured
		a. generated by a hardware devices
	iv. interrupts are also used to signal errors(traps or exception)

2. an operating system is an event-driven program

Process
1. A process contains all state of program in execution
	i An address space
	ii. Set of OS resouces
		• Open fils network connections
	iii. set of general-purpose registers with current values
2. A process is named by its process ID

Process Data Structures

How does the OS represent a process in the kernel?

1. At any time, there are many processes in the system
2. The OS data Structure representing each process is called process control block
3. The PCB contains all of the info about a process
4. The PCB also is where the OS keeps all of a process' hardware execution state when the process is not running
	- The execution state is everything that is needed to restore the hardware to the same configuration it was
	when the process is switched out of the hardware

Process Control Block includes
1. Process states(ready, running, blocked)
2. process counter: address of the next instruction
3. CPU registers: must be saved at an interrupt
4. CPU scheduling information: process priority
5. Memory management info: page tables
6. I/O status information: list of open files

linux PCB:
struct task_struct {
/* these are hardcoded - don't touch */
volatile long state; /* -1 unrunnable, 0 runnable, >0 stopped */
long counter; long priority; unsigned long signal;
unsigned long blocked; /* bitmap of masked signals */
unsigned long flags; /* per process flags, defined below */
int errno; long debugreg[8]; /* Hardware debugging registers */
struct exec_domain *exec_domain;
/* various fields */
struct linux_binfmt *binfmt;
struct task_struct *next_task, *prev_task;
struct task_struct *next_run, *prev_run;
unsigned long saved_kernel_stack;
unsigned long kernel_stack_page;
int exit_code, exit_signal; 

Process states & state changes

1. The OS manages processes by keeping track of their state
	- DIfferent events cause changes to a process state, which the OS must record/implement
States change
New (admit)-> Ready
Ready (dispatch) -> <- Running(time-out) (release) -> exit
Running (event-wait) -> Blocked(event occurs) ->Ready

State Queue
1. The OS maintains a collection of queues that represent the state of all processes in the system
2. Typically, the OS has one queue for each state(ready, waiting, etc)
3. Each PCB is queued on a state queue according to its current state
4. As a process chages state, its PCB is unlinked from one queue and linked to another

PCB and State Queues
1. PCBs are data structures dynamically allocated in OS memory
2. When a process is created, the OS allocated a PCB for it, initialized it, and place it on the Ready queue
3. As the process computes, does I/O, etc. Its PCB moves from one queue to another
4. when the process terminates, its PCB is de-allocated

Context Switch
1. Switch the CPU to another process, saving the state of the old process and loading the saved state for the
 new process
2. context swithc time is pure overhead, and some systems offer specific hardware support
3. A performance bottle neck, so new structures are being used to avoid it.

Operation on processes
1. Processes execute concurrently and must be created and deleted dynamically
2. Process creation:
	- System initialization
	- A running process
	- A user request
	- Initialization of a batch job
3. Process termination:
	- WHen a process finishes executing last statement
	- When a parent causes the termination of a child 
	- An error occurred

Process creation
1. A process is created by another process
 	- parent is creator, child is created
 		- in linux, the parent is the "PPID" field of "ps -f"
2. In some systems, the parent defines resources and privileges for its children
	- In Unix, process User ID is inherited - children of your shell execute with yur privileges

3. After creating a child , the parent may either wait for it to finishe its task or continue in parallel

Process creation : unix
1. In Unix, processes are created using fork()
	int fork()
2. fork()
	- Creates a new address space
	- Initializes the address space with a copy of the entire
	contents of the address space of the parent
	- Initializes the kernel resources to point to the resources
	used by parent (e.g., open files)
3. Fork returns twice
	- Returns the child’s PID to the parent, “0” to the child

Why fork()?
1. Very useful when the child…
	- Is cooperating with the parent
	- Relies upon the parent’s data to accomplish its task
2. Example: Web server
	while (1) {
		int sock = accept();
		if ((child_pid = fork()) == 0) {
		Handle client request
		} else {
		…..
}
}

Parallel programs

1. Create several processes that execute in parallel
2. create shared memory for processes to share data
3. have the OS schedule these processes in parallel
4. Very inefficient
5. The processes have same code and data, same privilege and same resources
6. Each has its own oxecution state: Program counter, SP, and registers

Thread: seperate the concept of a process from its execution state
1. Have threads in a process
2. It defines a sequential execution stream within a processes
3. The process defines the address space and general process attributes
4. A thread is bound to a single process
5. processes are containers in which threads execute

Cooperating Processes
1. A process is independent if it cannot affect or
be affected by the other processes executing
in the system
2. No data sharing  process is independent
3.  A process is cooperating if it is not
independent
4. Cooperating processes must be able to
communicate with each other and to
synchronize their actions















